---
title: "Untitled"
format: html
---

## Analysis of neutrophil subsets after lipid treatment

```{r}
library(CATALYST)
library(harmony)
library(cowplot)
library(flowCore)
library(scater)
library(SingleCellExperiment)
library(viridis)
library(RColorBrewer)
library(ggforce)
library(ggplot2)
library(ggrepel)
library(ggsci)
library(data.table)
library(emmeans)
library(dplyr)
library(tidyr)
library(ggsignif)
library(rstatix)
library(multcomp)
library(scales)
library(ggthemes)
library(slingshot)
library(ggbeeswarm)
library(ggbreak)
library(DescTools)
library(pak)
library(gghighlight)
library(scattermore)
library(clustree)
library(gridExtra)
library(patchwork)
library(ggbump)
library(stringr)
library(grid)
```

```{r}
setwd("C:/Users/dan94/OneDrive - University College London/UCL_Senior_Research_Fellow/Neutrophil_lipids/GSK_3uM_updated/")
```

## load in FCS files and create flowset object

### list fcs files in folder, choose ones required and then run read.flowset

```{r}
fcs <- list.files(pattern = ".fcs$")
fcs
fs <- read.flowSet(fcs, transformation = F, truncate_max_range = F)
```

## check columns (fluorophores)

## remove any not needed

## when running for the first time, save the columns into an excel to form the basis of the fluorophore metadata

## if this has been created before, just load it in

```{r}
all_cols <- colnames(fs)
all_cols
fs <- fs[,-c(1,2)]
colnames(fs)
cols <- colnames(fs)
cols <- as.data.frame(cols)
#write.csv(cols, file = "Marker.metadata.csv")
markers <- read.csv("Marker.metadata.csv")
markers
```

## use the file names as the basis for the sample metadata

## first add a column to make the sample id (removes excess characters at end of each fcs file name)

## use separate to add individual metadata features

## if script run previously then just load it in

```{r}
names <- data.frame(fcs)
sample_df <- names %>% mutate(sample_id = str_sub(fcs, 1, -24))
sample_df <- separate(sample_df, col = sample_id, into = c("donor", "treatment", "time"), remove = F, sep = "_")
write.csv(sample_df, file = "sample.metadata.csv")
samples <- read.csv("sample.metadata.csv")
```

## check channels from the flowest and markers metadata match

## make the singlecellexperiment object - here is where you set your cofactor values

### these can be assessed afterwards and this part can be re-done until the settings look correct

```{r}
setdiff(colnames(fs), markers$fluorophore)
setdiff(fcs, samples$fcs)

sce.custom <- prepData(x = fs, panel = markers, md = samples, FACS = T, transform = T, 
  cofactor = c("AF700-A" = 1000, "APC-A" = 1000, "APC-H7-A" = 1000, "BUV395-A" = 1000,        "BUV496-A" = 1000, "BUV563-A" = 1000, "BUV615-A" = 1000, "BUV737-A" = 1000, "BUV805-A" = 1000, "BV421-A" = 1000, "BV480-A" = 1000, "BV510-A" = 1000, "BV570-A" = 1000, "BV605-A" = 1000,     "BV785-A" = 1000, "FITC-A" = 1000, "PE-A" = 1000, "PacBlue-A" = 1000, "PerCP-Cy5.5-A" = 1000,  "SparkBlue-550-A" = 1000, "SparkYG-581-A" = 1000, "[Zombie UV]-A" = 1000), 
  panel_cols = list(channel = "fluorophore", antigen = "antigen"),
  md_cols = list(file = "fcs", id = "sample_id",
  factors = c("donor", "treatment", "time")))

table(sce.custom$donor)

plotExprs(sce.custom, color_by = "donor")
sce <- sce.custom
rm(sce.custom)
```

## downsample, as most of the time we have millions of cells

### not only computationaly limiting, but not really needed

### this function is from chatgpt, but seems to work well

```{r}
downsample <- function(sce, sample_col = "sample_id", proportion = 0.1, min_cells = 10) {
  # Get sample labels
  samples <- colData(sce)[[sample_col]]
  
  # For each sample, randomly select proportion of cells
  selected_cells <- unlist(lapply(unique(samples), function(s) {
    cells_in_sample <- which(samples == s)
    n <- max(round(length(cells_in_sample) * proportion), min_cells)  # enforce a minimum
    n <- min(length(cells_in_sample), n)  # avoid oversampling
    sample(cells_in_sample, n)
  }))
  
  # Subset the SCE to those cells
  sce_downsampled <- sce[, selected_cells]
  return(sce_downsampled)
}
numbers_before <- table(sce$sample_id)
sce <- downsample(sce, sample_col = "sample_id", proportion = 0.1)
numbers_after <- table(sce$sample_id)
```

## run batch correction using harmony - for this type of data i'm correcting on donor as each donor is processed, stained and run on separate occassions

```{r}
expdata <- sce@assays@data$exprs
meta <- sce@colData$donor
expdata <- t(expdata)
nrow(expdata)
nrow(meta)
harmony_output <- HarmonyMatrix(expdata, meta_data = meta, do_pca = F)
sce@assays@data$uncorrected <- sce@assays@data$exprs
sce@assays@data$exprs <- t(harmony_output)
```

## cluster, assess elbow plot

```{r}
set.seed(61)
sce <- CATALYST::cluster(sce, features = NULL, xdim = 10, ydim = 10, maxK = 30, verbose = T, seed = 61)

delta <- delta_area(sce)
delta <- delta$data
ggplot(delta, aes(x = k, y = y))+geom_point(size = 5)+geom_line(linewidth = 1.5)+
  theme_classic()+
  theme(axis.text = element_text(colour = "black", size = 18), 
        axis.title = element_text(size = 18, colour = "black"))+
  xlab("K (number of clusters)")+ylab("Relative change in \n area under CDF curve")
```

## create UMAP

```{r}
sce <- runDR(sce, "UMAP", features = NULL)
```

## this is a good point to save the object as the runDR takes a while, so we will load back in from here if needed

```{r}
saveRDS(sce, file = "neut_lipids_angela.rds", compress = F)
```

## before checking resolutions, plot umap by donor, treatment and time to see if any of these factors split it

```{r}
variables <- c("donor", "treatment", "time")
umaps <- list()
for (i in variables) {
umaps[[i]] <- plotDR(sce, "UMAP", color_by = i)+theme_bw()+
    geom_scattermore()
} 
p <- plot_grid(umaps$donor, umaps$treatment, umaps$time)
p
```

## if it looks reasonable (i.e doesn't split by donor, suggesting batche effect) start assessing the resolution (also known as meta or k)

### here i use the previously generated delta plot to get an idea of what an appropriate k might be - i then also "over-cluster" on purpose

## i also plot the expression of all markers in the umap. whilst this is computationally intensive and takes a while, it is worth it as it allows us to see if a marker is expressed across clusters or is distinct to one cluster

```{r}
res <- c("meta7", "meta10", "meta12", "meta15")
umaps <- list()

for (i in res) {
umaps[[i]] <- plotDR(sce, "UMAP", color_by = i)+theme_bw()+
    geom_scattermore()
} 

p1 <- plot_grid(umaps$meta7, umaps$meta10, umaps$meta12, umaps$meta15)
p1

ggsave(plot = p1, filename = "umaps_resolution_comparison.png", dpi = 500,
height = 6, width = 16)

markers.input <- markers$antigen
p2 <- plotDR(sce, color_by = markers.input)+theme_bw()
ggsave(plot = p2, filename = "umap_all_markers.png", dpi = 500,
height = 16, width = 16, bg = "white")
```

## a resolution of k10 looks appropriate, so plotting that in more detail

```{r}
p1 <- plotDR(sce, color_by = "meta10")+scale_colour_brewer(palette = "Paired")
p1
p2 <- plotDR(sce, color_by = "meta10")+facet_wrap(~meta10)+scale_colour_brewer(palette = "Paired")
p2
```

## make a crude annotation joins up tiny clusters into the large one for simplicity (this will be refined later)
## also going to filter out tiny clusters for the sake of this preliminary analysis
```{r}
sce <- filterSCE(sce, k = "meta10", cluster_id %in% c("1", "2", "3", "4", "6", "7", "8", "9"))
merging.table <- data.frame("original" = c(1,2,3,4,6,7,8,9), "labels" = c("1", "2", "2", "4", "6", "6", "6", "6"))

sce <- mergeClusters(sce, k = "meta10", table = merging.table, id = "labels", overwrite = T)

sce$labels <- cluster_ids(sce, k = "labels")
```

## before full annotation, we will briefly assess if treatment/time affect cluster proportions
## add k10 as a metadata column so that this can be used (add more here if required)
## then we pull out the data and make it into a dataframe, which is then easy to use for plotting

```{r}
sce$k10 <- cluster_ids(sce, "meta10")

ex <- assay(sce, "exprs")
neut.data <- data.frame(t(ex), sample_id = sce$sample_id, donor = sce$donor, 
                        treatment = sce$treatment, time = sce$time, 
                        k10 = sce$k10, labels = sce$labels)
#add umap dimensions
umap.coords <- data.frame(reducedDim(sce, "UMAP"))
neut.data$UMAP_1 <- umap.coords$UMAP1
neut.data$UMAP_2 <- umap.coords$UMAP2
```

## plot proportions as a stacked bar plot
## then export proportions as a csv file

```{r}
proportions <- neut.data %>% group_by(labels, treatment, time) %>% dplyr::count(labels, treatment, time)
proportions <- pivot_wider(proportions, names_from = labels, values_from = n)
proportions[is.na(proportions)] <- 0
proportions$total = rowSums(proportions[, c(3:6)])
proportions <- pivot_longer(proportions, names_to = "cluster", values_to = "number", 3:6)
proportions$prop <- (proportions$number/proportions$total)*100
proportions$time <- factor(proportions$time, levels = c("0h", "6h", "22h"))
p1 <- ggplot(proportions, aes(x = time, y = prop, fill = cluster))+geom_col()+theme_bw()+
  facet_wrap(~treatment, scales = "free_x", ncol = 1)+
  theme(axis.text = element_text(size = 12, colour = "black"))+theme(strip.text=element_text(size = 14, colour = "black", face = "bold"))
p1
ggsave(plot=p1, filename = "cluster_proportions_barplot.png", dpi = 500, height = 14, width = 4)

table_input <- proportions[, c(1,2,4,6)]
table_input <- pivot_wider(table_input, names_from = "time", values_from = "prop")
write.csv(table_input, file="proportions.table.csv")
```

## plotting umaps split by treatment+time for visualisation
```{r}
neut.data$time <- factor(neut.data$time, levels = c("0h", "6h", "22h"))
neut.data$treatment <- factor(neut.data$treatment, levels = c("Non-treated", "DiHOME", "EpOME", "GSK", "GSK+EpOME", "DMSO", "MA", "DMSO+MA"))
neut_baseline <- filter(neut.data, time %in% "0h")
neut_later <- filter(neut.data, time %in% c("6h", "22h"))

p1 <- ggplot(neut_baseline, aes(x = UMAP_1, y = UMAP_2, colour = labels))+geom_scattermore(pointsize = 2)+theme_bw()+
  facet_wrap(~treatment+time)+theme(strip.text=element_text(size = 14, colour = "black", face = "bold"))
p1
ggsave(plot = p1, filename = "umap_time+treatment_baseline.png", dpi = 500, height = 3, width = 4)

p2 <- ggplot(neut_later, aes(x = UMAP_1, y = UMAP_2, colour = labels))+geom_scattermore(pointsize = 2)+theme_bw()+
  facet_wrap(~treatment+time, ncol = 2)+theme(strip.text=element_text(size = 14, colour = "black", face = "bold"))
p2
ggsave(plot = p2, filename = "umap_time+treatment_6_22.png", dpi = 500, height = 14, width = 6)
```

##  violin of marker expression
```{r}
marker_df <- neut.data[, c(1:22,28)]
marker_df <- pivot_longer(marker_df, names_to = "marker", values_to = "expression", cols = 1:22)

p.violin <- ggplot(marker_df, aes(x = labels, y = expression, fill = labels))+geom_violin(scale = "width", trim = T)+
  facet_grid(rows = vars(marker), scales = "free", switch = "y")+theme_cowplot()+
  scale_y_continuous(expand = c(0, 0), position="right", labels = function(x)
    c(rep(x = "", times = length(x)-2), x[length(x) - 1], ""))+
  theme(legend.position = "none", panel.spacing = unit(0, "lines"),
        plot.title = element_text(hjust = 0.5),
        panel.background = element_rect(fill = NA, color = "black"),
        strip.background = element_blank(),
        strip.text = element_text(face = "bold"),
        strip.text.y.left = element_text(angle = 0, size = 14))+
  theme(axis.text.x = element_text(size = 14, colour = "black", angle = 45, hjust = 1))
p.violin
ggsave(plot=p.violin, filename = "violin_expression.png", dpi = 500,
height = 16, width = 6, bg = "white")
```